var documenterSearchIndex = {"docs":
[{"location":"#Historic.jl","page":"Historic.jl","title":"Historic.jl","text":"","category":"section"},{"location":"#Defining-recorder","page":"Historic.jl","title":"Defining recorder","text":"","category":"section"},{"location":"","page":"Historic.jl","title":"Historic.jl","text":"Historic.@define\nHistoric.Scratch","category":"page"},{"location":"#Historic.@define","page":"Historic.jl","title":"Historic.@define","text":"Historic.@define RecordModule\n\nDefine a module named RecordModule with a private event recording buffer.\n\nRecordModule.@record(name, k₁ = v₁, …)\n\nRecordModule defines the following overloadable functions:\n\nRecordModule.defaultdata() returns a named tuple to be included in the event record by default.\nRecordModule.prefix() returns a string to be used asa prefix of the log message.\nRecordModule.isrecording() returns a Bool indicating if the events recorded by RecordModule.@record should be recorded by default.\n\n\n\n\n\n","category":"macro"},{"location":"#Historic.Scratch","page":"Historic.jl","title":"Historic.Scratch","text":"Historic.Scratch\n\nPre-defined recorder module generated by Historic.@define Scratch. Historic.@record is an alias of Historic.Scratch.@record.\n\n\n\n\n\n","category":"module"},{"location":"#Defining-events","page":"Historic.jl","title":"Defining events","text":"","category":"section"},{"location":"","page":"Historic.jl","title":"Historic.jl","text":"Historic.Scratch.@record","category":"page"},{"location":"#Historic.Scratch.@record","page":"Historic.jl","title":"Historic.Scratch.@record","text":"@record($name, $k₁ = $v₁, …, $kₙ = $vₙ)\n@record($name, $k₁ = $v₁, …, $kₙ = $vₙ, {$a₁ = $b₁, …, $aₙ = $bₙ})\n\nRecord event named $name and optional event data (key-value pairs $kᵢ = $vᵢ) with optional control arguments $aᵢ = $bᵢ.\n\nExtended help\n\nExamples\n\n@record(:n1) records an event named :n1.\n@record(:n2, k1 = 0) records an event named :n2 with optional data key k1 and value 0.\n@record(rand(Bool) ? :n3 : :n4) records either an event named :n3 or an event named :n4.\n@record(:n5, {log = nothing}) records an event without logging it.\n\nArguments\n\nThe first argument $name is an expression evaluates to a Symbol.\n\nIf the last argument is wrapped in a pair of { and }, it is treated as a set of control argument (see below).\n\nThe rest of the arguments are optional. Each of these argument is either an assignment of form $k = $v or a variable name $k. The latter is equivalent to $k = $k.\n\nOptional control argument\n\nIf the last argument is of form {$a₁ = $b₁, …, $aₙ = $bₙ}, each assignment expression $a = $b specifies a (non-data) control option.\n\nlog ($b::Union{Nothing,NamedTuple}): Options to the logger. log = nothing disables logging.\nyield ($b::Bool): Passing yield = false tries to avoid code paths that may yield to the scheduler.\n\n\n\n\n\n","category":"macro"},{"location":"#Tools-for-defining-event-data","page":"Historic.jl","title":"Tools for defining event data","text":"","category":"section"},{"location":"","page":"Historic.jl","title":"Historic.jl","text":"Historic.taskid\nHistoric.objid\nHistoric.uniqueid","category":"page"},{"location":"#Historic.taskid","page":"Historic.jl","title":"Historic.taskid","text":"Historic.taskid(task::Task = current_task())\n\nGet a (pseudo) id for a task.\n\nIt does not uniquely identify a task (thus \"pseudo\") when the task is garbage collected and the corresponding memory region is re-used.\n\n\n\n\n\n","category":"function"},{"location":"#Historic.objid","page":"Historic.jl","title":"Historic.objid","text":"Historic.objid(x)\n\nGet a (pseudo) id for arbitrary object x.\n\nIt does not uniquely identify an object (thus \"pseudo\") when the object is garbage collected and the corresponding memory region is re-used.\n\n\n\n\n\n","category":"function"},{"location":"#Historic.uniqueid","page":"Historic.jl","title":"Historic.uniqueid","text":"Historic.uniqueid() -> id::UInt64\n\nGenerate a number unique within a julia process.\n\n\n\n\n\n","category":"function"},{"location":"#Recording-events","page":"Historic.jl","title":"Recording events","text":"","category":"section"},{"location":"","page":"Historic.jl","title":"Historic.jl","text":"Historic.clear","category":"page"},{"location":"#Historic.clear","page":"Historic.jl","title":"Historic.clear","text":"Historic.clear()\nHistoric.clear(recordmodule::Module)\n\nRemove recorded events.\n\n\n\n\n\n","category":"function"},{"location":"#Analyzing-events","page":"Historic.jl","title":"Analyzing events","text":"","category":"section"},{"location":"","page":"Historic.jl","title":"Historic.jl","text":"Historic.events\nHistoric.flattable","category":"page"},{"location":"#Historic.events","page":"Historic.jl","title":"Historic.events","text":"Historic.events() -> eventtable\nHistoric.events(recordmodule::Module) -> eventtable\n\nReturn a table of events recoded by recordmodule.@record. If used without an argument, return all events in all recorder modules.\n\n\n\n\n\n","category":"function"},{"location":"#Historic.flattable","page":"Historic.jl","title":"Historic.flattable","text":"Historic.flattable() -> flattable\nHistoric.flattable(recordmodule::Module) -> flattable\nHistoric.flattable(eventtable) -> flattable\n\nReturn a flatten table of events; i.e., all custom event data key-value pairs passed to @record can accessed as columns.\n\nSee also Historic.events.\n\n\n\n\n\n","category":"function"}]
}
